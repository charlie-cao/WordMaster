# ğŸš€ WordMaster å…¨é¢ç³»ç»Ÿä¼˜åŒ–å»ºè®®

## ğŸ“‹ ç›®å½•
1. [å‰ç«¯æ€§èƒ½ä¼˜åŒ–](#å‰ç«¯æ€§èƒ½ä¼˜åŒ–)
2. [å®‰å…¨æ€§å¢å¼º](#å®‰å…¨æ€§å¢å¼º)
3. [APIä¼˜åŒ–](#apiä¼˜åŒ–)
4. [ç”¨æˆ·ä½“éªŒä¼˜åŒ–](#ç”¨æˆ·ä½“éªŒä¼˜åŒ–)
5. [ç³»ç»Ÿæ¶æ„ä¼˜åŒ–](#ç³»ç»Ÿæ¶æ„ä¼˜åŒ–)
6. [ç›‘æ§ä¸è¿ç»´](#ç›‘æ§ä¸è¿ç»´)
7. [AIä¸æ™ºèƒ½åŒ–](#aiä¸æ™ºèƒ½åŒ–)

---

## ğŸ¨ å‰ç«¯æ€§èƒ½ä¼˜åŒ–

### 1. ç»„ä»¶æ‡’åŠ è½½ä¸ä»£ç åˆ†å‰²

#### å½“å‰é—®é¢˜
- æ‰€æœ‰é¡µé¢ç»„ä»¶éƒ½åœ¨åˆå§‹åŠ è½½æ—¶åŠ è½½
- å›¾è¡¨ç»„ä»¶ï¼ˆRechartsï¼‰å ç”¨å¤§é‡bundle
- å•è¯å­¦ä¹ é¡µé¢ç»„ä»¶è¾ƒé‡

#### è§£å†³æ–¹æ¡ˆ
```typescript
// åŠ¨æ€å¯¼å…¥ç»„ä»¶
const StatsPage = dynamic(() => import('@/app/stats/page'), {
  loading: () => <LoadingSkeleton />,
  ssr: false
});

const ProgressChart = dynamic(() => import('@/components/charts/ProgressChart'), {
  loading: () => <div className="h-64 bg-gray-200 animate-pulse rounded" />,
  ssr: false
});

// è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
const StudyPage = dynamic(() => import('@/app/study/page'), {
  loading: () => <StudyLoadingSkeleton />,
  ssr: false
});
```

#### æ€§èƒ½æå‡
- **é¦–å±åŠ è½½æ—¶é—´**: å‡å°‘ 40-60%
- **Bundleå¤§å°**: å‡å°‘ 30-50%
- **äº¤äº’å“åº”**: æå‡ 2-3 å€

### 2. å›¾ç‰‡ä¸èµ„æºä¼˜åŒ–

#### å½“å‰é—®é¢˜
- æ²¡æœ‰å›¾ç‰‡ä¼˜åŒ–ç­–ç•¥
- é™æ€èµ„æºæœªå‹ç¼©
- ç¼ºå°‘WebPæ ¼å¼æ”¯æŒ

#### è§£å†³æ–¹æ¡ˆ
```typescript
// next.config.js ä¼˜åŒ–é…ç½®
const nextConfig = {
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  compress: true,
  poweredByHeader: false,
  generateEtags: false,
  
  // èµ„æºä¼˜åŒ–
  webpack: (config, { dev, isServer }) => {
    if (!dev && !isServer) {
      config.optimization.splitChunks.cacheGroups = {
        ...config.optimization.splitChunks.cacheGroups,
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        charts: {
          test: /[\\/]node_modules[\\/](recharts|d3)[\\/]/,
          name: 'charts',
          chunks: 'all',
        }
      };
    }
    return config;
  }
};
```

### 3. çŠ¶æ€ç®¡ç†ä¼˜åŒ–

#### å½“å‰é—®é¢˜
- ç»„ä»¶çŠ¶æ€ç®¡ç†åˆ†æ•£
- æ²¡æœ‰å…¨å±€çŠ¶æ€ç®¡ç†
- é‡å¤çš„APIè°ƒç”¨

#### è§£å†³æ–¹æ¡ˆ
```typescript
// ä½¿ç”¨ Zustand è¿›è¡ŒçŠ¶æ€ç®¡ç†
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AppState {
  user: User | null;
  words: Word[];
  studyProgress: StudyProgress;
  isLoading: boolean;
  
  // Actions
  setUser: (user: User | null) => void;
  fetchWords: () => Promise<void>;
  updateProgress: (progress: StudyProgress) => void;
}

export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      user: null,
      words: [],
      studyProgress: {},
      isLoading: false,
      
      setUser: (user) => set({ user }),
      
      fetchWords: async () => {
        set({ isLoading: true });
        try {
          const response = await fetch('/api/words');
          const data = await response.json();
          if (data.success) {
            set({ words: data.data.words });
          }
        } finally {
          set({ isLoading: false });
        }
      },
      
      updateProgress: (progress) => set({ studyProgress: progress }),
    }),
    {
      name: 'wordmaster-store',
      partialize: (state) => ({ 
        user: state.user,
        studyProgress: state.studyProgress 
      }),
    }
  )
);
```

### 4. è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–

#### å½“å‰é—®é¢˜
- å•è¯åˆ—è¡¨ä¸€æ¬¡æ€§æ¸²æŸ“æ‰€æœ‰é¡¹ç›®
- å¤§é‡å•è¯æ—¶æ€§èƒ½ä¸‹é™
- å†…å­˜å ç”¨è¿‡é«˜

#### è§£å†³æ–¹æ¡ˆ
```typescript
// è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶
import { FixedSizeList as List } from 'react-window';

const VirtualizedWordList = ({ words }: { words: Word[] }) => {
  const Row = ({ index, style }: { index: number; style: any }) => (
    <div style={style}>
      <WordCard word={words[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={words.length}
      itemSize={120}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

---

## ğŸ”’ å®‰å…¨æ€§å¢å¼º

### 1. APIå®‰å…¨é˜²æŠ¤

#### å½“å‰é—®é¢˜
- ç¼ºå°‘APIé€Ÿç‡é™åˆ¶
- æ²¡æœ‰è¯·æ±‚éªŒè¯ä¸­é—´ä»¶
- ç¼ºå°‘CSRFä¿æŠ¤

#### è§£å†³æ–¹æ¡ˆ
```typescript
// é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// APIé€Ÿç‡é™åˆ¶
export const apiLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redis.call(...args),
  }),
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100, // é™åˆ¶æ¯ä¸ªIP 15åˆ†é’Ÿå†…æœ€å¤š100ä¸ªè¯·æ±‚
  message: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
  standardHeaders: true,
  legacyHeaders: false,
});

// ç™»å½•é€Ÿç‡é™åˆ¶
export const loginLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redis.call(...args),
  }),
  windowMs: 15 * 60 * 1000,
  max: 5, // 15åˆ†é’Ÿå†…æœ€å¤š5æ¬¡ç™»å½•å°è¯•
  message: 'ç™»å½•å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·15åˆ†é’Ÿåå†è¯•',
  skipSuccessfulRequests: true,
});
```

#### 2. è¾“å…¥éªŒè¯å¢å¼º

```typescript
// ä½¿ç”¨ Joi è¿›è¡Œæ•°æ®éªŒè¯
import Joi from 'joi';

const userRegistrationSchema = Joi.object({
  email: Joi.string().email().required().max(255),
  username: Joi.string().alphanum().min(2).max(20).required(),
  password: Joi.string().min(8).pattern(/^(?=.*[a-zA-Z])(?=.*\d)/).required(),
  confirmPassword: Joi.string().valid(Joi.ref('password')).required()
});

const wordSearchSchema = Joi.object({
  search: Joi.string().max(100).pattern(/^[a-zA-Z\s]*$/),
  difficulty: Joi.string().valid('easy', 'medium', 'hard'),
  page: Joi.number().integer().min(1).max(1000),
  limit: Joi.number().integer().min(1).max(100)
});

// éªŒè¯ä¸­é—´ä»¶
export const validateRequest = (schema: Joi.ObjectSchema) => {
  return (req: NextRequest, res: NextResponse, next: Function) => {
    const { error } = schema.validate(req.body || req.query);
    if (error) {
      return NextResponse.json({
        success: false,
        error: error.details[0].message
      }, { status: 400 });
    }
    next();
  };
};
```

#### 3. å®‰å…¨å¤´è®¾ç½®

```typescript
// å®‰å…¨ä¸­é—´ä»¶
export const securityHeaders = (req: NextRequest, res: NextResponse) => {
  res.headers.set('X-Frame-Options', 'DENY');
  res.headers.set('X-Content-Type-Options', 'nosniff');
  res.headers.set('Referrer-Policy', 'origin-when-cross-origin');
  res.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  res.headers.set('X-XSS-Protection', '1; mode=block');
  
  if (process.env.NODE_ENV === 'production') {
    res.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    res.headers.set('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline';");
  }
  
  return res;
};
```

---

## ğŸ”Œ APIä¼˜åŒ–

### 1. GraphQLé›†æˆ

#### å½“å‰é—®é¢˜
- REST APIè¿‡åº¦è·å–æ•°æ®
- å¤šæ¬¡APIè°ƒç”¨
- å‰ç«¯éœ€è¦çš„æ•°æ®ç»“æ„ä¸åŒ¹é…

#### è§£å†³æ–¹æ¡ˆ
```typescript
// GraphQL Schema
import { buildSchema } from 'graphql';

const schema = buildSchema(`
  type User {
    id: ID!
    username: String!
    email: String!
    stats: UserStats!
    words: [Word!]!
  }

  type Word {
    id: ID!
    word: String!
    pronunciation: String!
    definitions: [WordDefinition!]!
    difficulty: Difficulty!
    tags: [String!]!
  }

  type UserStats {
    totalWords: Int!
    masteredWords: Int!
    currentStreak: Int!
    averageAccuracy: Float!
  }

  type Query {
    user(id: ID!): User
    words(difficulty: Difficulty, limit: Int, offset: Int): [Word!]!
    randomWords(count: Int!, difficulty: Difficulty): [Word!]!
  }

  type Mutation {
    updateProgress(userId: ID!, wordId: ID!, isCorrect: Boolean!): Boolean!
    createWordset(name: String!, description: String!): WordSet!
  }

  enum Difficulty {
    EASY
    MEDIUM
    HARD
  }
`);

// GraphQL Resolver
const resolvers = {
  Query: {
    user: async (parent, args) => {
      return await UserService.getUserById(args.id);
    },
    words: async (parent, args) => {
      return await WordService.getWords(args);
    }
  },
  Mutation: {
    updateProgress: async (parent, args) => {
      return await ProgressService.updateProgress(args);
    }
  }
};
```

### 2. APIç‰ˆæœ¬æ§åˆ¶

```typescript
// APIç‰ˆæœ¬æ§åˆ¶
export const apiVersion = (version: string) => {
  return (req: NextRequest, res: NextResponse, next: Function) => {
    req.apiVersion = version;
    next();
  };
};

// ç‰ˆæœ¬åŒ–è·¯ç”±
// /api/v1/words
// /api/v2/words
```

### 3. APIæ–‡æ¡£è‡ªåŠ¨åŒ–

```typescript
// ä½¿ç”¨ Swagger/OpenAPI
import { generateApi } from 'swagger-typescript-api';

// è‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
const apiConfig = {
  name: 'WordMaster API',
  version: '1.0.0',
  description: 'WordMasterå­¦ä¹ ç³»ç»ŸAPIæ–‡æ¡£',
  servers: [
    {
      url: process.env.API_BASE_URL || 'http://localhost:3000/api',
      description: 'å¼€å‘ç¯å¢ƒ'
    }
  ],
  tags: [
    { name: 'auth', description: 'è®¤è¯ç›¸å…³' },
    { name: 'words', description: 'å•è¯ç›¸å…³' },
    { name: 'study', description: 'å­¦ä¹ ç›¸å…³' }
  ]
};
```

---

## ğŸ¯ ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 1. ç¦»çº¿æ”¯æŒ

#### å½“å‰é—®é¢˜
- æ²¡æœ‰ç¦»çº¿å­¦ä¹ åŠŸèƒ½
- ç½‘ç»œæ–­å¼€æ—¶æ— æ³•ä½¿ç”¨
- å­¦ä¹ è¿›åº¦å¯èƒ½ä¸¢å¤±

#### è§£å†³æ–¹æ¡ˆ
```typescript
// Service Worker å®ç°
// public/sw.js
const CACHE_NAME = 'wordmaster-v1';
const urlsToCache = [
  '/',
  '/dashboard',
  '/study',
  '/api/words',
  '/manifest.json'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // è¿”å›ç¼“å­˜çš„ç‰ˆæœ¬æˆ–ä»ç½‘ç»œè·å–
        return response || fetch(event.request);
      })
  );
});

// ç¦»çº¿æ•°æ®åŒæ­¥
class OfflineSync {
  private pendingActions: any[] = [];

  async syncWhenOnline() {
    if (navigator.onLine) {
      for (const action of this.pendingActions) {
        await this.executeAction(action);
      }
      this.pendingActions = [];
    }
  }

  addPendingAction(action: any) {
    this.pendingActions.push(action);
  }
}
```

### 2. æ¸è¿›å¼Webåº”ç”¨(PWA)

```typescript
// manifest.json
{
  "name": "WordMaster - æ™ºèƒ½å•è¯å­¦ä¹ ",
  "short_name": "WordMaster",
  "description": "åŸºäºAIçš„æ™ºèƒ½å•è¯å­¦ä¹ åº”ç”¨",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3b82f6",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### 3. æ™ºèƒ½å­¦ä¹ æ¨è

```typescript
// å­¦ä¹ æ¨èç®—æ³•
class LearningRecommendation {
  async getRecommendedWords(userId: string, limit: number = 10): Promise<Word[]> {
    const user = await UserService.getUserById(userId);
    const userProgress = await ProgressService.getUserProgress(userId);
    
    // åŸºäºç”¨æˆ·æ°´å¹³æ¨è
    const difficulty = this.calculateUserDifficulty(userProgress);
    
    // åŸºäºå­¦ä¹ å†å²æ¨è
    const learnedWords = userProgress.map(p => p.wordId);
    const recommendedWords = await WordService.getWordsByDifficulty(difficulty, limit);
    
    // è¿‡æ»¤å·²å­¦å•è¯
    return recommendedWords.filter(word => !learnedWords.includes(word._id));
  }

  private calculateUserDifficulty(progress: UserProgress[]): string {
    const accuracy = progress.reduce((acc, p) => acc + p.accuracy, 0) / progress.length;
    
    if (accuracy > 0.8) return 'hard';
    if (accuracy > 0.6) return 'medium';
    return 'easy';
  }
}
```

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„ä¼˜åŒ–

### 1. å¾®æœåŠ¡æ¶æ„

#### å½“å‰é—®é¢˜
- å•ä½“åº”ç”¨ï¼Œæ‰©å±•å›°éš¾
- æœåŠ¡è€¦åˆåº¦é«˜
- éƒ¨ç½²å¤æ‚

#### è§£å†³æ–¹æ¡ˆ
```yaml
# docker-compose.microservices.yml
version: '3.8'

services:
  # ç”¨æˆ·æœåŠ¡
  user-service:
    build: ./services/user-service
    environment:
      - DATABASE_URL=${USER_DB_URL}
      - REDIS_URL=${REDIS_URL}
    ports:
      - "3001:3000"

  # å•è¯æœåŠ¡
  word-service:
    build: ./services/word-service
    environment:
      - DATABASE_URL=${WORD_DB_URL}
      - REDIS_URL=${REDIS_URL}
    ports:
      - "3002:3000"

  # å­¦ä¹ æœåŠ¡
  study-service:
    build: ./services/study-service
    environment:
      - DATABASE_URL=${STUDY_DB_URL}
      - REDIS_URL=${REDIS_URL}
    ports:
      - "3003:3000"

  # APIç½‘å…³
  api-gateway:
    build: ./services/api-gateway
    ports:
      - "3000:3000"
    depends_on:
      - user-service
      - word-service
      - study-service

  # æ¶ˆæ¯é˜Ÿåˆ—
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
```

### 2. å®¹å™¨åŒ–ä¼˜åŒ–

```dockerfile
# å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

FROM base AS deps
RUN npm ci --only=production && npm cache clean --force

FROM base AS builder
COPY . .
RUN npm ci
RUN npm run build

FROM base AS runner
ENV NODE_ENV production
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]
```

### 3. è´Ÿè½½å‡è¡¡

```typescript
// Nginx é…ç½®
upstream wordmaster_backend {
    least_conn;
    server app1:3000 weight=3 max_fails=3 fail_timeout=30s;
    server app2:3000 weight=3 max_fails=3 fail_timeout=30s;
    server app3:3000 weight=2 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name wordmaster.com;

    location / {
        proxy_pass http://wordmaster_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # é™æ€èµ„æºç¼“å­˜
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

---

## ğŸ“Š ç›‘æ§ä¸è¿ç»´

### 1. åº”ç”¨æ€§èƒ½ç›‘æ§(APM)

```typescript
// æ€§èƒ½ç›‘æ§
import { PerformanceObserver } from 'perf_hooks';

class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  startMonitoring() {
    // Web Vitals ç›‘æ§
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric(entry.name, entry.value);
      }
    }).observe({ entryTypes: ['measure', 'navigation'] });

    // API å“åº”æ—¶é—´ç›‘æ§
    this.monitorAPIResponseTimes();
  }

  private monitorAPIResponseTimes() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const start = performance.now();
      const response = await originalFetch(...args);
      const duration = performance.now() - start;
      
      this.recordMetric('api_response_time', duration);
      return response;
    };
  }

  private recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  getMetrics() {
    const result: Record<string, any> = {};
    for (const [name, values] of this.metrics) {
      result[name] = {
        count: values.length,
        average: values.reduce((a, b) => a + b, 0) / values.length,
        min: Math.min(...values),
        max: Math.max(...values)
      };
    }
    return result;
  }
}
```

### 2. é”™è¯¯ç›‘æ§

```typescript
// é”™è¯¯ç›‘æ§å’Œä¸ŠæŠ¥
class ErrorMonitor {
  private errorQueue: Error[] = [];

  init() {
    // å…¨å±€é”™è¯¯æ•è·
    window.addEventListener('error', (event) => {
      this.captureError(event.error);
    });

    // Promise é”™è¯¯æ•è·
    window.addEventListener('unhandledrejection', (event) => {
      this.captureError(event.reason);
    });

    // React é”™è¯¯è¾¹ç•Œ
    this.setupReactErrorBoundary();
  }

  private captureError(error: Error) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    this.errorQueue.push(errorInfo);
    this.sendErrorsToServer();
  }

  private async sendErrorsToServer() {
    if (this.errorQueue.length > 0) {
      try {
        await fetch('/api/errors', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(this.errorQueue)
        });
        this.errorQueue = [];
      } catch (error) {
        console.error('Failed to send errors to server:', error);
      }
    }
  }
}
```

### 3. å¥åº·æ£€æŸ¥

```typescript
// å¥åº·æ£€æŸ¥ç«¯ç‚¹
export async function GET() {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      database: await checkDatabaseHealth(),
      redis: await checkRedisHealth(),
      external: await checkExternalServices()
    }
  };

  const isHealthy = Object.values(health.services).every(service => service.status === 'healthy');
  
  return NextResponse.json(health, { 
    status: isHealthy ? 200 : 503 
  });
}

async function checkDatabaseHealth() {
  try {
    const db = await getDatabase();
    await db.admin().ping();
    return { status: 'healthy', responseTime: Date.now() };
  } catch (error) {
    return { status: 'unhealthy', error: error.message };
  }
}
```

---

## ğŸ¤– AIä¸æ™ºèƒ½åŒ–

### 1. æ™ºèƒ½å­¦ä¹ ç®—æ³•

```typescript
// åŸºäºæœºå™¨å­¦ä¹ çš„ä¸ªæ€§åŒ–æ¨è
class AILearningEngine {
  private model: any;

  async trainModel(userData: UserLearningData[]) {
    // ä½¿ç”¨ TensorFlow.js è®­ç»ƒæ¨¡å‹
    const model = tf.sequential({
      layers: [
        tf.layers.dense({ inputShape: [10], units: 64, activation: 'relu' }),
        tf.layers.dense({ units: 32, activation: 'relu' }),
        tf.layers.dense({ units: 1, activation: 'sigmoid' })
      ]
    });

    model.compile({
      optimizer: 'adam',
      loss: 'binaryCrossentropy',
      metrics: ['accuracy']
    });

    // è®­ç»ƒæ•°æ®å‡†å¤‡
    const trainingData = this.prepareTrainingData(userData);
    
    await model.fit(trainingData.x, trainingData.y, {
      epochs: 100,
      validationSplit: 0.2
    });

    this.model = model;
  }

  async predictDifficulty(word: Word, user: User): Promise<number> {
    if (!this.model) {
      return 0.5; // é»˜è®¤ä¸­ç­‰éš¾åº¦
    }

    const features = this.extractFeatures(word, user);
    const prediction = this.model.predict(features);
    return prediction.dataSync()[0];
  }

  private extractFeatures(word: Word, user: User): tf.Tensor {
    return tf.tensor2d([[
      word.frequency,
      user.stats.averageAccuracy,
      user.stats.currentStreak,
      word.definitions.length,
      user.stats.totalWords,
      // ... æ›´å¤šç‰¹å¾
    ]]);
  }
}
```

### 2. è‡ªç„¶è¯­è¨€å¤„ç†

```typescript
// æ™ºèƒ½å•è¯åˆ†æ
class WordAnalyzer {
  async analyzeWord(word: string): Promise<WordAnalysis> {
    // è¯æ€§åˆ†æ
    const pos = await this.getPartOfSpeech(word);
    
    // è¯æ ¹åˆ†æ
    const root = await this.extractRoot(word);
    
    // åŒä¹‰è¯åˆ†æ
    const synonyms = await this.getSynonyms(word);
    
    // ä½¿ç”¨é¢‘ç‡åˆ†æ
    const frequency = await this.getFrequency(word);
    
    return {
      word,
      partOfSpeech: pos,
      root,
      synonyms,
      frequency,
      difficulty: this.calculateDifficulty(frequency, pos)
    };
  }

  async generateContextualExamples(word: string): Promise<string[]> {
    // ä½¿ç”¨AIç”Ÿæˆä¸Šä¸‹æ–‡ä¾‹å¥
    const prompt = `Generate 3 example sentences using the word "${word}" in different contexts.`;
    
    const response = await fetch('/api/ai/generate-examples', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ word, prompt })
    });
    
    return response.json();
  }
}
```

### 3. è¯­éŸ³è¯†åˆ«ä¸åˆæˆ

```typescript
// è¯­éŸ³å­¦ä¹ åŠŸèƒ½
class SpeechLearning {
  private recognition: SpeechRecognition;

  constructor() {
    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    this.setupRecognition();
  }

  private setupRecognition() {
    this.recognition.lang = 'en-US';
    this.recognition.continuous = false;
    this.recognition.interimResults = false;
  }

  async practicePronunciation(word: string): Promise<PronunciationResult> {
    return new Promise((resolve) => {
      this.recognition.onresult = (event) => {
        const spokenWord = event.results[0][0].transcript.toLowerCase().trim();
        const accuracy = this.calculatePronunciationAccuracy(word, spokenWord);
        
        resolve({
          spokenWord,
          accuracy,
          isCorrect: accuracy > 0.8
        });
      };

      this.recognition.start();
    });
  }

  private calculatePronunciationAccuracy(expected: string, spoken: string): number {
    // ä½¿ç”¨ç¼–è¾‘è·ç¦»ç®—æ³•è®¡ç®—å‘éŸ³å‡†ç¡®åº¦
    const distance = this.levenshteinDistance(expected, spoken);
    return Math.max(0, 1 - distance / expected.length);
  }

  speakWord(word: string, options: SpeechOptions = {}) {
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = options.lang || 'en-US';
    utterance.rate = options.rate || 0.8;
    utterance.pitch = options.pitch || 1;
    
    speechSynthesis.speak(utterance);
  }
}
```

---

## ğŸ“ˆ å®æ–½ä¼˜å…ˆçº§

### ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰ï¼šåŸºç¡€ä¼˜åŒ–
1. **å‰ç«¯æ€§èƒ½ä¼˜åŒ–**
   - ç»„ä»¶æ‡’åŠ è½½
   - ä»£ç åˆ†å‰²
   - å›¾ç‰‡ä¼˜åŒ–

2. **å®‰å…¨æ€§å¢å¼º**
   - APIé€Ÿç‡é™åˆ¶
   - è¾“å…¥éªŒè¯
   - å®‰å…¨å¤´è®¾ç½®

### ç¬¬äºŒé˜¶æ®µï¼ˆ2-3å‘¨ï¼‰ï¼šæ¶æ„ä¼˜åŒ–
1. **APIä¼˜åŒ–**
   - GraphQLé›†æˆ
   - APIç‰ˆæœ¬æ§åˆ¶
   - æ–‡æ¡£è‡ªåŠ¨åŒ–

2. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**
   - ç¦»çº¿æ”¯æŒ
   - PWAåŠŸèƒ½
   - æ™ºèƒ½æ¨è

### ç¬¬ä¸‰é˜¶æ®µï¼ˆ3-4å‘¨ï¼‰ï¼šé«˜çº§åŠŸèƒ½
1. **ç³»ç»Ÿæ¶æ„ä¼˜åŒ–**
   - å¾®æœåŠ¡æ¶æ„
   - å®¹å™¨åŒ–ä¼˜åŒ–
   - è´Ÿè½½å‡è¡¡

2. **AIä¸æ™ºèƒ½åŒ–**
   - æ™ºèƒ½å­¦ä¹ ç®—æ³•
   - è‡ªç„¶è¯­è¨€å¤„ç†
   - è¯­éŸ³åŠŸèƒ½

### ç¬¬å››é˜¶æ®µï¼ˆæŒç»­ï¼‰ï¼šç›‘æ§ä¸è¿ç»´
1. **ç›‘æ§ç³»ç»Ÿ**
   - APMç›‘æ§
   - é”™è¯¯ç›‘æ§
   - å¥åº·æ£€æŸ¥

2. **è¿ç»´è‡ªåŠ¨åŒ–**
   - CI/CDæµæ°´çº¿
   - è‡ªåŠ¨éƒ¨ç½²
   - æ•…éšœæ¢å¤

---

## ğŸ’° æˆæœ¬æ•ˆç›Šåˆ†æ

### å¼€å‘æˆæœ¬
- **ç¬¬ä¸€é˜¶æ®µ**: 2-3å‘¨ï¼Œ2-3äºº
- **ç¬¬äºŒé˜¶æ®µ**: 3-4å‘¨ï¼Œ3-4äºº
- **ç¬¬ä¸‰é˜¶æ®µ**: 4-6å‘¨ï¼Œ4-5äºº
- **ç¬¬å››é˜¶æ®µ**: æŒç»­ï¼Œ1-2äºº

### æ€§èƒ½æ”¶ç›Š
- **åŠ è½½é€Ÿåº¦**: æå‡ 50-70%
- **ç”¨æˆ·ä½“éªŒ**: æ˜¾è‘—æ”¹å–„
- **ç³»ç»Ÿç¨³å®šæ€§**: æå‡ 80%
- **å¼€å‘æ•ˆç‡**: æå‡ 40%

### å•†ä¸šä»·å€¼
- **ç”¨æˆ·ç•™å­˜**: æå‡ 30-50%
- **ç”¨æˆ·æ»¡æ„åº¦**: æå‡ 40-60%
- **ç³»ç»Ÿå¯æ‰©å±•æ€§**: æå‡ 5-10å€
- **è¿ç»´æˆæœ¬**: é™ä½ 30-40%

---

## ğŸ¯ æ€»ç»“

é€šè¿‡å®æ–½è¿™äº›å…¨é¢çš„ä¼˜åŒ–å»ºè®®ï¼ŒWordMasterç³»ç»Ÿå°†è·å¾—ï¼š

1. **æ€§èƒ½æå‡**: æ•´ä½“æ€§èƒ½æå‡ 3-5 å€
2. **ç”¨æˆ·ä½“éªŒ**: æ˜¾è‘—æ”¹å–„çš„äº¤äº’ä½“éªŒ
3. **ç³»ç»Ÿç¨³å®šæ€§**: æ›´é«˜çš„å¯é æ€§å’Œå¯ç»´æŠ¤æ€§
4. **æ™ºèƒ½åŒ–**: AIé©±åŠ¨çš„ä¸ªæ€§åŒ–å­¦ä¹ ä½“éªŒ
5. **å¯æ‰©å±•æ€§**: æ”¯æŒæ›´å¤§è§„æ¨¡çš„ç”¨æˆ·å¢é•¿

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„äº¤ä»˜æˆæœå’Œæ€§èƒ½æå‡ã€‚é€šè¿‡æŒç»­çš„ä¼˜åŒ–å’Œç›‘æ§ï¼Œç³»ç»Ÿå°†èƒ½å¤Ÿä¸ºç”¨æˆ·æä¾›æ›´ä¼˜è´¨çš„å­¦ä¹ ä½“éªŒã€‚
